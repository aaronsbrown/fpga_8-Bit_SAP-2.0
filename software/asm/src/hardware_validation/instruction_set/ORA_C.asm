; Enhanced ORA_C Instruction Test Suite
; Tests the ORA_C (bitwise OR A with C) instruction comprehensively
; 
; Instruction: ORA_C (opcode $35)
; Operation: A = A | C
; Flags: Z=+/- (result), N=+/- (result), C=0 (cleared)
; Bytes: 1

    org $F000

start:
    ; ================================================================
    ; TEST 1: Basic OR operation - A=$00 | C=$FF = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$00    ; A = 00000000
    LDI C, #$FF    ; C = 11111111
    LDI B, #$BB    ; B = test marker (should be preserved)
    ORA C          ; A = A | C = 00000000 | 11111111 = 11111111

    ; ================================================================
    ; TEST 2: Basic OR operation - A=$FF | C=$00 = $FF  
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$FF    ; A = 11111111
    LDI C, #$00    ; C = 00000000
    ORA C          ; A = A | C = 11111111 | 00000000 = 11111111

    ; ================================================================
    ; TEST 3: OR operation resulting in zero - A=$00 | C=$00 = $00
    ; Expected: A=$00, Z=1, N=0, C=0
    ; ================================================================
    LDI A, #$00    ; A = 00000000
    LDI C, #$00    ; C = 00000000
    ORA C          ; A = A | C = 00000000 | 00000000 = 00000000

    ; ================================================================
    ; TEST 4: Alternating pattern 1 - A=$55 | C=$AA = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$55    ; A = 01010101
    LDI C, #$AA    ; C = 10101010
    ORA C          ; A = A | C = 01010101 | 10101010 = 11111111

    ; ================================================================
    ; TEST 5: Alternating pattern 2 - A=$AA | C=$55 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$AA    ; A = 10101010
    LDI C, #$55    ; C = 01010101
    ORA C          ; A = A | C = 10101010 | 01010101 = 11111111

    ; ================================================================
    ; TEST 6: Partial overlap - A=$0F | C=$F0 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$0F    ; A = 00001111
    LDI C, #$F0    ; C = 11110000
    ORA C          ; A = A | C = 00001111 | 11110000 = 11111111

    ; ================================================================
    ; TEST 7: Single bit operations - A=$01 | C=$80 = $81
    ; Expected: A=$81, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$01    ; A = 00000001
    LDI C, #$80    ; C = 10000000
    ORA C          ; A = A | C = 00000001 | 10000000 = 10000001

    ; ================================================================
    ; TEST 8: Same value OR - A=$42 | C=$42 = $42
    ; Expected: A=$42, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$42    ; A = 01000010
    LDI C, #$42    ; C = 01000010
    ORA C          ; A = A | C = 01000010 | 01000010 = 01000010

    ; ================================================================
    ; TEST 9: Positive result from negative operands - A=$C0 | C=$30 = $F0
    ; Expected: A=$F0, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$C0    ; A = 11000000
    LDI C, #$30    ; C = 00110000
    ORA C          ; A = A | C = 11000000 | 00110000 = 11110000

    ; ================================================================
    ; TEST 10: Carry flag clearing test - set carry, then OR
    ; Expected: A=$7F, Z=0, N=0, C=0 (carry cleared by ORA_C)
    ; ================================================================
    SEC            ; Set carry flag to 1
    LDI A, #$3F    ; A = 00111111
    LDI C, #$40    ; C = 01000000
    ORA C          ; A = A | C = 00111111 | 01000000 = 01111111, C=0

    ; ================================================================
    ; TEST 11: All zeros except LSB - A=$01 | C=$00 = $01
    ; Expected: A=$01, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$01    ; A = 00000001
    LDI C, #$00    ; C = 00000000
    ORA C          ; A = A | C = 00000001 | 00000000 = 00000001

    ; ================================================================
    ; TEST 12: All zeros except MSB - A=$80 | C=$00 = $80
    ; Expected: A=$80, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$80    ; A = 10000000
    LDI C, #$00    ; C = 00000000
    ORA C          ; A = A | C = 10000000 | 00000000 = 10000000

    ; ================================================================
    ; TEST 13: Complex bit pattern - A=$69 | C=$96 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$69    ; A = 01101001
    LDI C, #$96    ; C = 10010110
    ORA C          ; A = A | C = 01101001 | 10010110 = 11111111

    ; ================================================================
    ; TEST 14: Subset pattern - A=$0C | C=$03 = $0F
    ; Expected: A=$0F, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$0C    ; A = 00001100
    LDI C, #$03    ; C = 00000011
    ORA C          ; A = A | C = 00001100 | 00000011 = 00001111

    ; ================================================================
    ; TEST 15: Edge case - maximum positive | minimum positive = $7F
    ; Expected: A=$7F, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$7F    ; A = 01111111
    LDI C, #$01    ; C = 00000001
    ORA C          ; A = A | C = 01111111 | 00000001 = 01111111

    ; ================================================================
    ; TEST 16: Register preservation test
    ; Verify that B and C registers are not corrupted by ORA_C (except C is the operand)
    ; ================================================================
    LDI A, #$3C    ; A = 00111100
    LDI B, #$5A    ; B = 01011010 (should be preserved)
    LDI C, #$5A    ; C = 01011010 (operand)
    ORA C          ; A = A | C = 00111100 | 01011010 = 01111110
    ; B should still be $5A, C should still be $5A

    ; ================================================================
    ; TEST 17: All bits set except one - A=$FE | C=$01 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$FE    ; A = 11111110
    LDI C, #$01    ; C = 00000001
    ORA C          ; A = A | C = 11111110 | 00000001 = 11111111

    ; ================================================================
    ; TEST 18: Sequential OR operations to verify no side effects
    ; ================================================================
    LDI A, #$01    ; A = 00000001
    LDI C, #$02    ; C = 00000010
    ORA C          ; A = A | C = 00000001 | 00000010 = 00000011
    
    LDI C, #$04    ; C = 00000100
    ORA C          ; A = A | C = 00000011 | 00000100 = 00000111
    
    LDI C, #$08    ; C = 00001000
    ORA C          ; A = A | C = 00000111 | 00001000 = 00001111

    ; ================================================================
    ; TEST 19: Boundary value testing - A=$7F | C=$80 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$7F    ; A = 01111111 (max positive)
    LDI C, #$80    ; C = 10000000 (min negative)
    ORA C          ; A = A | C = 01111111 | 10000000 = 11111111

    ; ================================================================
    ; TEST 20: Final flag state verification
    ; Set up specific flag states and verify ORA_C behavior
    ; ================================================================
    SEC            ; Set carry (should be cleared)
    LDI A, #$00    ; A = 00000000, sets Z=1
    LDI C, #$00    ; C = 00000000
    ORA C          ; A = A | C = 00000000, Z=1, N=0, C=0

    HLT            ; End of test program