; Enhanced ORA_B Instruction Test Suite
; Tests the ORA_B (bitwise OR A with B) instruction comprehensively
; 
; Instruction: ORA_B (opcode $34)
; Operation: A = A | B
; Flags: Z=+/- (result), N=+/- (result), C=0 (cleared)
; Bytes: 1

    org $F000

start:
    ; ================================================================
    ; TEST 1: Basic OR operation - A=$00 | B=$FF = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$00    ; A = 00000000
    LDI B, #$FF    ; B = 11111111
    LDI C, #$CC    ; C = test marker (should be preserved)
    ORA B          ; A = A | B = 00000000 | 11111111 = 11111111

    ; ================================================================
    ; TEST 2: Basic OR operation - A=$FF | B=$00 = $FF  
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$FF    ; A = 11111111
    LDI B, #$00    ; B = 00000000
    ORA B          ; A = A | B = 11111111 | 00000000 = 11111111

    ; ================================================================
    ; TEST 3: OR operation resulting in zero - A=$00 | B=$00 = $00
    ; Expected: A=$00, Z=1, N=0, C=0
    ; ================================================================
    LDI A, #$00    ; A = 00000000
    LDI B, #$00    ; B = 00000000
    ORA B          ; A = A | B = 00000000 | 00000000 = 00000000

    ; ================================================================
    ; TEST 4: Alternating pattern 1 - A=$55 | B=$AA = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$55    ; A = 01010101
    LDI B, #$AA    ; B = 10101010
    ORA B          ; A = A | B = 01010101 | 10101010 = 11111111

    ; ================================================================
    ; TEST 5: Alternating pattern 2 - A=$AA | B=$55 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$AA    ; A = 10101010
    LDI B, #$55    ; B = 01010101
    ORA B          ; A = A | B = 10101010 | 01010101 = 11111111

    ; ================================================================
    ; TEST 6: Partial overlap - A=$0F | B=$F0 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$0F    ; A = 00001111
    LDI B, #$F0    ; B = 11110000
    ORA B          ; A = A | B = 00001111 | 11110000 = 11111111

    ; ================================================================
    ; TEST 7: Single bit operations - A=$01 | B=$80 = $81
    ; Expected: A=$81, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$01    ; A = 00000001
    LDI B, #$80    ; B = 10000000
    ORA B          ; A = A | B = 00000001 | 10000000 = 10000001

    ; ================================================================
    ; TEST 8: Same value OR - A=$42 | B=$42 = $42
    ; Expected: A=$42, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$42    ; A = 01000010
    LDI B, #$42    ; B = 01000010
    ORA B          ; A = A | B = 01000010 | 01000010 = 01000010

    ; ================================================================
    ; TEST 9: Positive result from negative operands - A=$C0 | B=$30 = $F0
    ; Expected: A=$F0, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$C0    ; A = 11000000
    LDI B, #$30    ; B = 00110000
    ORA B          ; A = A | B = 11000000 | 00110000 = 11110000

    ; ================================================================
    ; TEST 10: Carry flag clearing test - set carry, then OR
    ; Expected: A=$7F, Z=0, N=0, C=0 (carry cleared by ORA_B)
    ; ================================================================
    SEC            ; Set carry flag to 1
    LDI A, #$3F    ; A = 00111111
    LDI B, #$40    ; B = 01000000
    ORA B          ; A = A | B = 00111111 | 01000000 = 01111111, C=0

    ; ================================================================
    ; TEST 11: All zeros except LSB - A=$01 | B=$00 = $01
    ; Expected: A=$01, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$01    ; A = 00000001
    LDI B, #$00    ; B = 00000000
    ORA B          ; A = A | B = 00000001 | 00000000 = 00000001

    ; ================================================================
    ; TEST 12: All zeros except MSB - A=$80 | B=$00 = $80
    ; Expected: A=$80, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$80    ; A = 10000000
    LDI B, #$00    ; B = 00000000
    ORA B          ; A = A | B = 10000000 | 00000000 = 10000000

    ; ================================================================
    ; TEST 13: Complex bit pattern - A=$69 | B=$96 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$69    ; A = 01101001
    LDI B, #$96    ; B = 10010110
    ORA B          ; A = A | B = 01101001 | 10010110 = 11111111

    ; ================================================================
    ; TEST 14: Subset pattern - A=$0C | B=$03 = $0F
    ; Expected: A=$0F, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$0C    ; A = 00001100
    LDI B, #$03    ; B = 00000011
    ORA B          ; A = A | B = 00001100 | 00000011 = 00001111

    ; ================================================================
    ; TEST 15: Edge case - maximum positive | minimum positive = $7F
    ; Expected: A=$7F, Z=0, N=0, C=0
    ; ================================================================
    LDI A, #$7F    ; A = 01111111
    LDI B, #$01    ; B = 00000001
    ORA B          ; A = A | B = 01111111 | 00000001 = 01111111

    ; ================================================================
    ; TEST 16: Register preservation test
    ; Verify that B and C registers are not corrupted by ORA_B
    ; ================================================================
    LDI A, #$3C    ; A = 00111100
    LDI B, #$5A    ; B = 01011010 (should be preserved)
    LDI C, #$A5    ; C = 10100101 (should be preserved)
    ORA B          ; A = A | B = 00111100 | 01011010 = 01111110
    ; B should still be $5A, C should still be $A5

    ; ================================================================
    ; TEST 17: All bits set except one - A=$FE | B=$01 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$FE    ; A = 11111110
    LDI B, #$01    ; B = 00000001
    ORA B          ; A = A | B = 11111110 | 00000001 = 11111111

    ; ================================================================
    ; TEST 18: Sequential OR operations to verify no side effects
    ; ================================================================
    LDI A, #$01    ; A = 00000001
    LDI B, #$02    ; B = 00000010
    ORA B          ; A = A | B = 00000001 | 00000010 = 00000011
    
    LDI B, #$04    ; B = 00000100
    ORA B          ; A = A | B = 00000011 | 00000100 = 00000111
    
    LDI B, #$08    ; B = 00001000
    ORA B          ; A = A | B = 00000111 | 00001000 = 00001111

    ; ================================================================
    ; TEST 19: Boundary value testing - A=$7F | B=$80 = $FF
    ; Expected: A=$FF, Z=0, N=1, C=0
    ; ================================================================
    LDI A, #$7F    ; A = 01111111 (max positive)
    LDI B, #$80    ; B = 10000000 (min negative)
    ORA B          ; A = A | B = 01111111 | 10000000 = 11111111

    ; ================================================================
    ; TEST 20: Final flag state verification
    ; Set up specific flag states and verify ORA_B behavior
    ; ================================================================
    SEC            ; Set carry (should be cleared)
    LDI A, #$00    ; A = 00000000, sets Z=1
    LDI B, #$00    ; B = 00000000
    ORA B          ; A = A | B = 00000000, Z=1, N=0, C=0

    HLT            ; End of test program